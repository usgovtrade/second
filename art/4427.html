<!DOCTYPE html><html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'><script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8422244967817077' crossorigin=anonymous'></script><link rel='stylesheet' href='/class.css'><script src='/script.js'></script></head><body><div class='topnav'></div><div class='list'><Br/><a href='4428.html'>/*
 * This file is</a><Br/><a href='4429.html'>The present disclo</a><Br/><a href='4430.html'>Kentucky Football </a><Br/><a href='4431.html'>---
abstract: 'Ion</a><Br/><a href='4432.html'>It's just like a b</a><Br/><a href='4433.html'>#
# Copyright 2017</a><Br/><a href='4434.html'>Q:

What is the be</a><Br/><a href='4435.html'>If this is your fi</a><Br/><a href='4436.html'>Namco Bandai has n</a><Br/><a href='4437.html'>Invasive and trans</a></div><div class='stats'><div class='logodiv'><a href='/'><img class='logoimg' src='/img/elephant.svg' /></a></div> <Br/><a href='4426.html'>Q:

How to create </a><Br/><a href='4425.html'>Q:

How to access </a><Br/><a href='4424.html'>New Mexico Gov. Su</a><Br/><a href='4423.html'>This invention rel</a><Br/><a href='4422.html'>It may be just wee</a><Br/><a href='4421.html'>AUSTIN - After two</a><Br/><a href='4420.html'>Brasil: Ao menos c</a><Br/><a href='4419.html'>In recent years, t</a><Br/><a href='4418.html'>As part of a pilot</a><Br/><a href='4417.html'>//  SuperTux
//  C</a></div><div class='nav'><a href='4426.html'> << </a>&nbsp;&nbsp;&nbsp;&nbsp;<a href='4428.html'> >> </a></div><div class='article'>Q:

how to remove all the file extensions but keep the extension of last file?

Suppose there are a lot of files in my desktop, such as :
a.txt
b.jpg
c.doc
d.gif
e.xls
...
n.pdf

I want to rename them to their original name:
a
b.jpg
c.doc
d.gif
e.xls
...
n.pdf

How can I do this in the linux command line? I'm sure the shell command is very simple and quick, but how to do this step?

A:

for i in *.* ; do mv -i $i ${i%.*}. ; done

(with bash on MacOSX (tested on 10.9) with an extension of .txt):
$ for i in *.txt; do mv -i $i ${i%.*}.txt ; done

$ ls
d.gif  n.pdf  p.txt  p.xls

$ for i in *.* ; do echo $i; done
a
b.jpg
c.doc
d.gif
e.xls
...
n.pdf
$ mv -i a b.jpg c.doc d.gif e.xls ... n.pdf 
$ for i in *.* ; do echo $i; done
a
b.jpg
c.doc
d.gif
e.xls
...
n.pdf
$

What does mv -i do?
The parameter $i represents the filename. 
The shell removes the extensions and returns the filename without extension.
Then mv renames the file.

man mv:
  -i     prompt before overwriting a file

A:

In BASH:
for file in *
do
  mv $file `echo $file | sed -E 's/\.[^.]+$//'`
done

or:
for file in *
do
  mv $file ${file%.*}.
done

Or, a shorter method (which does not change the current working directory):
for file in *
do
  mv -n $file `echo $file | sed -E 's/\.[^.]+$//'`
done

If you use "mv", you cannot go back and change your mind.

A:

In Mac OS, you can do it by double-clicking the file name in the Open dialog box in Finder and hitting command-shift-a.
Here is the command:
find ~/Desktop -iname \*.{png,mp3,gif,jpg,jpeg,pdf} -exec mv {} ~/Desktop/\`basename {} .{png,mp3,gif,jpg,jpeg,pdf}\` \;

This will make the files have their original extensions.

NOTE: This can be done easily in bash as well. This is a shell script which will move all files on desktop and change their extensions in one go:
for file in ~/Desktop/*;
do
if [ ! -f "$file" ];
then
echo "Skipping ${file##*/} because it's not a file"
else
mv "$file" `basename "$file"`
fi
done

Explanation:
Here find command gets executed, it will find all files in ~/Desktop which has extension mentioned in the regex, i.e. *.png, *.mp3 etc. ~ is the tilde which means home folder and * tells find to match all files in all folders (so make sure you don't have hidden files in Desktop).
The && if is an AND condition, if it's false, the IF branch gets ignored and move command gets executed. so there is a -f file check if file exists and return true or false.
Once file is found it gets moved and file name is stripped from it's extension by basename command.
To remove file extension you don't need to strip anything as you are creating new file names without extensions and moving original files.

To do it via command line:
find ~/Desktop -iname \*.{png,mp3,gif,jpg,jpeg,pdf} -exec mv {} ~/Desktop/\`basename {} .{png,mp3,gif,jpg,jpeg,pdf}\` \;

Explanation:
find gets executed here with one argument "*.png,mp3,gif,jpg,jpeg,pdf".
{} is a file found which is replaced by mv as you may see.
".{png,mp3,gif,jpg,jpeg,pdf}" is a file name string in which we strip the extensions from file name.
\$ is a sign of a string in Bash and \` gives the string escaped from shell (otherwise, this would've been just a dollar sign in front of a backtick).
basename takes the file name without its extension and concatenates the string "basename" in front of it. Then it returns the result.
"~/Desktop/basename {}.png,mp3,gif,jpg,jpeg,pdf" is a file name.
If no filename matches your pattern (basename pattern is empty) or extension check fails, then echo will be executed and you'll be told that your file doesn't exist or is not a file.
It is also possible to call mv only if file exists:
find ~/Desktop -iname \*.{png,mp3,gif,jpg,jpeg,pdf} -type f -exec mv {} ~/Desktop/\`basename {} .{png,mp3,gif,jpg,jpeg,pdf}\` \;

This way you can perform certain checks before actually moving the file. For example, to check if file is empty (using -empty switch of find):
find ~/Desktop -iname \*.{png,mp3,gif,jpg,jpeg,pdf} -</div></body></html><!-- 2022-07-17 11:29:20 